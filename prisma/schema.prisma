// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [postgis(version: "3.3.2")]
}

model Signal {
  signal_ulid        String   @id @default(cuid())
  signal_type        SignalType?
  signal_title       String?
  signal_description String?  @db.Text
  signal_author      String?
  signal_source      String?

  // Geography
  signal_latitude    Decimal? @db.Decimal(10, 8)
  signal_longitude   Decimal? @db.Decimal(11, 8)

  // Processing state
  signal_status      SignalStatus @default(PENDING)

  // Privacy level
  signal_visibility  SignalVisibility @default(PUBLIC)

  // Flexible data storage
  signal_metadata    Json?    @db.JsonB

  // Signal payload (can include pre-processing annotations)
  signal_payload     Json?    @db.JsonB // Content + annotations

  signal_tags        Json?    @db.JsonB

  // Timestamps
  stamp_created      DateTime
  stamp_updated      DateTime? @updatedAt
  stamp_seeded       DateTime?

  // Relations
  metadata     Metadata[] @relation("MetadataToSignal")
  reflections  Reflection[] @relation("ReflectionToSignal")
  clusters           ClusterSignal[]

  @@map("kernel_signals")
  @@index([signal_author])
  @@index([signal_status])
  @@index([signal_visibility])
  @@index([signal_type])
  @@index([stamp_created])
  @@index([stamp_seeded])
}

enum SignalType {
  PHOTO
  VIDEO
  AUDIO
  TEXT
  LOCATION
}

enum SignalStatus {
  PENDING      // Waiting for AI processing
  PROCESSING   // AI extraction running
  PROCESSED    // Metadata extracted
  FAILED       // Processing error
}

enum SignalVisibility {
  PUBLIC       // Anyone can see
  PRIVATE      // Only owner
  SANCTUM      // Protected space
}

// ============================================================================
// METADATA - AI extraction layer WITH FULL AUDIT TRAIL
// ============================================================================

model Metadata {
  metadata_ulid      String   @id @default(cuid())

  // Polymorphic target
  target_ulid        String
  target_type        String   // 'signal' or 'cluster'

  // Relations
  signal    Signal?  @relation("MetadataToSignal", fields: [target_ulid], references: [signal_ulid], onDelete: Cascade, map: "metadata_signal_fkey")
  cluster   Cluster? @relation("MetadataToCluster", fields: [target_ulid], references: [cluster_ulid], onDelete: Cascade, map: "metadata_cluster_fkey")

  // Extraction metadata
  metadata_type      String?
  metadata_depth     String   @default("signal")

  // Current extracted data (latest successful version)
  metadata_content   Json?    @db.JsonB // themes, patterns, sentiment

  // Processing info (current)
  metadata_provider  String?  // 'anthropic', 'openai', 'local'
  metadata_model     String?  // 'claude-sonnet-4-20250514', etc.

  // Annotations (pre-processing instructions)
  metadata_annotations Json?  @db.JsonB // Instructions to AI about this signal

  // Audit trail (ALL attempts, preserved forever)
  metadata_history   Json     @db.JsonB // Array of processing attempts

  // Error tracking
  metadata_errors    Json?    @db.JsonB // Array of errors encountered

  // Timestamps
  stamp_created      DateTime
  stamp_updated      DateTime? @updatedAt

  @@map("kernel_metadata")
  @@index([target_type])
  @@index([target_ulid])
}

// ============================================================================
// REFLECTION - Narrative synthesis layer
// ============================================================================

model Reflection {
  reflection_ulid    String   @id @default(cuid())

  // Target (Signal or Cluster)
  target_ulid        String
  target_type        String   // 'signal' or 'cluster'

  // Relations
  signal    Signal?  @relation("ReflectionToSignal", fields: [target_ulid], references: [signal_ulid], onDelete: Cascade, map: "reflection_signal_fkey")
  cluster   Cluster? @relation("ReflectionToCluster", fields: [target_ulid], references: [cluster_ulid], onDelete: Cascade, map: "reflection_cluster_fkey")

  // Reflection type
  reflection_type    ReflectionType

  // Content
  reflection_title   String?
  reflection_content String   @db.Text

  // Metadata
  reflection_author  String?
  reflection_meta    Json?    @db.JsonB

  // Timestamps
  stamp_created      DateTime
  stamp_updated      DateTime? @updatedAt

  @@map("kernel_reflections")
  @@index([target_ulid])
  @@index([target_type])
  @@index([reflection_type])
}

enum ReflectionType {
  MIRROR      // High-fidelity representation
  MYTH        // Archetypal pattern
  NARRATIVE   // Structured storytelling
}

// ============================================================================
// CLUSTER - Grouped signals
// ============================================================================

model Cluster {
  cluster_ulid       String   @id @default(cuid())
  cluster_type       ClusterType?
  cluster_title      String?
  cluster_notes      Json?    @db.JsonB
  cluster_tags       Json?    @db.JsonB
  cluster_metadata   Json?    @db.JsonB
  cluster_state      String

  // Temporal bounds
  stamp_cluster_start DateTime?
  stamp_cluster_end   DateTime?
  stamp_created       DateTime

  // Relations
  signals            ClusterSignal[]
  metadata     Metadata[] @relation("MetadataToCluster")
  reflections  Reflection[] @relation("ReflectionToCluster")

  @@map("kernel_clusters")
  @@index([cluster_type])
  @@index([cluster_state])
  @@index([stamp_cluster_start])
  @@index([stamp_cluster_end])
}

enum ClusterType {
  TEMPORAL   // Time-based grouping
  SPATIAL    // Location-based grouping
  THEMATIC   // Content similarity
  MANUAL     // User-created
}

// ============================================================================
// CLUSTER_SIGNAL - Many-to-many pivot table
// ============================================================================

model ClusterSignal {
  cluster_ulid       String
  signal_ulid        String

  cluster            Cluster  @relation(fields: [cluster_ulid], references: [cluster_ulid], onDelete: Cascade)
  signal             Signal   @relation(fields: [signal_ulid], references: [signal_ulid], onDelete: Cascade)

  // Pivot metadata
  position           Int?
  pivot_metadata     Json?    @db.JsonB
  stamp_added        DateTime

  @@id([cluster_ulid, signal_ulid])
  @@map("kernel_cluster_signals")
  @@index([cluster_ulid])
  @@index([signal_ulid])
}

// ============================================================================
// USER - Basic user model
// ============================================================================

model User {
  user_ulid     String   @id @default(cuid())
  user_email    String   @unique
  user_name     String?

  stamp_created DateTime @default(now())
  stamp_updated DateTime @updatedAt

  @@map("kernel_users")
  @@index([user_email])
}
